# Taking Stock of Your Usage

分片集合時，您選擇一個或兩個字段用於拆分數據。 此密鑰（一個或多個）稱為分片密鑰。 分片集合後，您將無法更改分片密鑰，因此正確選擇很重要。

要選擇一個好的分片密鑰，您需要了解您的工作量以及分片密鑰將如何分發應用程序的請求。 這可能很難想像，所以請嘗試列出一些示例，或者甚至更好地在具有示例流量的備份數據集上進行嘗試。 本節有很多圖表和說明，但是沒有替代品可以對您自己的數據進行嘗試。

對於您計劃分片的每個集合，請首先回答以下問題：

您打算增長到多少個碎片？三碎片集群比千碎片集群具有更大的靈活性。隨著群集變大，您不應該計劃觸發可能會擊中所有分片的查詢，因此幾乎所有查詢都必須包含分片鍵。

您是否正在努力減少讀取或寫入延遲？ （延遲是指某件事情要花費多長時間；例如，寫入要花費20毫秒，但您需要花費10毫秒。）減少寫入延遲通常需要將請求發送到地理位置更近或更強大的計算機。

您是否要增加讀取或寫入吞吐量？ （吞吐量是指集群可以同時處理多少個請求；例如，集群可以在20毫秒內完成1000次寫入，但是您需要在20毫秒內進行5000次寫入。）提高吞吐量通常涉及添加更多的並行化和確保請求在群集中平均分配。

您是否要增加系統資源（例如，為MongoDB每GB數據提供更多RAM）？如果是這樣，您希望將工作集大小保持盡可能小。

使用這些答案來評估以下分片鍵說明，並確定您正在考慮的分片鍵在您的情況下是否可以正常使用。 它能為您提供所需的目標查詢嗎？ 它會以您需要的方式改變系統的吞吐量或延遲嗎？ 如果您需要一個緊湊的工作台，它可以提供嗎？

# Picturing Distributions

人們選擇拆分數據的最常見方法是通過升序，隨機和基於位置的密鑰。 可以使用其他類型的密鑰，但是大多數用例屬於這些類別之一。 以下各節討論了不同類型的分佈。

## 升序分片鍵

升序分片鍵通常類似於“日期”字段或ObjectId-隨時間穩定增長的任何東西。 自動遞增主鍵是升序字段的另一個示例，儘管該字段在MongoDB中顯示的很少（除非您要從另一個數據庫導入）。

假設我們在一個遞增字段上進行分片，例如使用ObjectIds在集合上進行“ _id”分片。 如果我們對“ _id”進行分片，那麼數據將被分成“ _id”範圍的塊，如圖16-1所示。 這些塊將分佈在我們的三個分片的分片集群中，如圖16-2所示。

假設我們創建一個新文檔。 它在哪一塊？ 答案是范圍從$ maxKey到ObjectId（“ 5112fae0b4a4b396ff9d0ee5”）的塊。 這稱為最大塊，因為它是包含$ maxKey的塊。

如果我們插入另一個文檔，它也將在最大塊中。 實際上，每個後續插入都將進入最大塊！ 每個插入項的“ _id”字段都將比前一個字段更接近無窮大（因為ObjectId始終是遞增的），因此它們都將進入max塊。

這具有幾個有趣的（通常是不受歡迎的）屬性。 首先，您所有的寫操作都將路由到一個分片（本例中為shard0002）。 該塊將是唯一一個成長和分裂的塊，因為它是唯一接收插入的塊。 插入數據時，新的塊將“掉下”該塊，如圖16-3所示。

這種模式通常使MongoDB很難保持塊均勻平衡，因為所有塊都是由一個分片創建的。 因此，MongoDB必須不斷將塊移動到其他分片，而不是糾正分佈更均勻的系統中可能出現的微小失衡。

**note**

在MongoDB 4.2中，自動拆分功能向分片主mongod的移動增加了頂級塊優化，以解決遞增的分片鍵模式。 平衡器將決定在哪個其他分片中放置頂部塊。 這有助於避免僅在一個分片上創建所有新塊的情況。

## Randomly Distributed Shard Keys

在頻譜的另一端是隨機分佈的分片密鑰。 隨機分佈的密鑰可以是用戶名，電子郵件地址，UUID，MD5哈希或數據集中沒有可識別模式的任何其他密鑰。

假設分片密鑰是0到1之間的一個隨機數。我們最終將在各個分片上隨機分配塊，如圖16-4所示。

隨著插入更多數據，數據的隨機性意味著插入應該相當均勻地擊中每個塊。 您可以通過插入10,000個文檔並查看它們的最終位置來證明這一點：

由於寫入是隨機分佈的，因此分片應以大致相同的速率增長，從而限制了需要進行的遷移次數。 隨機分配的分片鍵的唯一缺點是，MongoDB在隨機訪問超出RAM大小的數據方面效率不高。 但是，如果您有能力或不介意性能下降，則隨機鍵可以很好地在整個群集中分配負載。

## Location-Based Shard Keys

基於位置的分片鍵可能是用戶的IP，緯度和經度或地址之類的東西。它們不一定與物理位置字段相關：“位置”可能是將數據分組在一起的更抽象的方式。在任何情況下，基於位置的密鑰都是具有某些相似性的文檔基於此字段落入範圍的密鑰。這對於將數據靠近其用戶並將相關數據保持在磁盤上都非常方便。保持符合GDPR或其他類似數據隱私法規的法律要求也可能是法律。 MongoDB使用分區分區來管理此任務。

**注意**
在MongoDB 4.0.3+中，您可以在分片集合之前定義區域和區域範圍，該集合將為區域範圍和分片鍵值填充塊，並對其進行初始塊分配。這大大降低了分片區域設置的複雜性。

例如，假設我們有一個在IP地址上分片的文檔集合。如圖16-5所示，文檔將根據其IP被組織成塊，並隨機分佈在整個集群中。

如果我們希望將某些塊範圍附加到某些分片，則可以對這些分片進行分區，然後將塊範圍分配給每個分區。 在此示例中，假設我們希望將某些IP塊保留在某些分片上：例如，56。*。*。*（美國郵政服務的IP塊）保留在shard0000和17。*。*。*（Apple的IP塊）上 在shard0000或shard0002上。 我們不在乎其他IP的位置。 我們可以要求平衡器通過設置區域來做到這一點：

當平衡器移動塊時，它將嘗試將那些範圍內的塊移動到這些碎片。 請注意，此過程不是立即進行的。 沒有被區域鍵範圍覆蓋的塊將正常移動。 平衡器將繼續嘗試在碎片之間平均分配塊。

# Shard Key Strategies

本節介紹了用於各種類型應用程序的許多分片鍵選項。

## 哈希碎片鍵

為了盡可能快地加載數據，哈希分片鍵是最佳選擇。 哈希分片鍵可以使任何字段隨機分佈，因此，如果您要在許多查詢中使用升序鍵，但又希望寫入是隨機分佈，則這是一個不錯的選擇。 折衷方案是您永遠無法使用哈希分片鍵進行目標範圍查詢。 但是，如果您不進行範圍查詢，則哈希分片鍵是一個不錯的選擇。

如果在不存在的集合上創建散列的分片鍵，則shardCollection的行為會很有趣：它假定您想要均勻分佈的塊，因此它會立即創建一堆空塊並將其分佈在群集中。 例如，假設我們的集群在創建散列分片鍵之前如下所示：

請注意，集合中還沒有文檔，但是當您開始插入文檔時，寫入數據應該從一開始就均勻地分佈在各個分片上。 通常，您將不得不等待塊增長，分裂和移動以開始寫入其他分片。 借助這種自動啟動功能，您將立即在所有分片上獲得塊範圍。

**注意**

如果您使用的是哈希分片密鑰，則分片密鑰會有一些限制。 首先，您不能使用唯一選項。 與其他分片鍵一樣，您不能使用數組字段。 最後，請注意，在散列之前，浮點值將四捨五入為整數，因此1和1.999999都將被散列為相同的值。


## Hashed Shard Keys for GridFS

在嘗試分片GridFS集合之前，請確保您了解GridFS如何存儲數據（請參見第6章
說明）。

在以下說明中，術語“塊”是重載的，因為GridFS將文件拆分為塊，而分片將集合拆分為塊。因此，這兩種類型的塊稱為“ GridFS塊”和“分片塊”。

GridFS集合通常包含大量文件數據，因此非常適合用於分片。但是，在fs.chunks上自動創建的兩個索引都不是特別好的分片鍵：{“ _id”：1}是升序鍵，{“ files_id”：1，“ n”：1}會拾取fs.files的“ _id”字段，因此它也是一個升序鍵。

但是，如果在“ files_id”字段上創建哈希索引，則每個文件將在整個群集中隨機分佈，並且一個文件將始終包含在單個塊中。這是兩全其美的做法：寫入將平均分配給所有分片，而讀取文件的數據則只需擊中單個分片即可。

要進行設置，必須在{“ files_id”：“ hashed”}上創建一個新索引（在撰寫本文時，mongos不能將復合索引的子集用作分片鍵）。然後在該字段上分片集合：

附帶說明一下，fs.files集合可能需要分片，也可能不需要分片，因為它比fs.chunks小得多。 您可以根據需要將其分片，但這不是必需的。

## 消防軟管策略

如果您擁有一些比其他服務器更強大的服務器，則可能希望讓它們比不那麼強大的服務器按比例處理更多的負載。 例如，假設您有一個可以處理其他計算機負載10倍的分片。 幸運的是，您還有另外10個分片。 您可以強制將所有插入內容移到功能更強大的分片上，然後允許平衡器將較舊的塊移動到其他分片上。 這將提供較低延遲的寫入。 

要使用此策略，我們必須將最高的塊固定到功能更強大的分片上。首先，我們對該分區進行分區：

現在，所有插入將被路由到最後一個塊，該塊將始終位於分區“ 10x”上。

但是，除非我們修改區域鍵範圍，否則從現在到無限的範圍將被困在此碎片上。 為了解決這個問題，我們可以設置一個cron作業來每天更新一次密鑰範圍，如下所示：

然後，前一天的所有塊都可以移至其他碎片。 該策略的另一個缺點是，它需要對規模進行一些更改。 

如果功能最強大的服務器不再能夠處理傳入的寫入次數，則沒有簡單的方法可以在該服務器和另一台服務器之間分配負載。

如果您沒有高性能的服務器可以使用，或者您沒有使用區域分片，請不要使用升序鍵作為分片鍵。 如果這樣做，所有寫操作將進入一個分片。

## Multi-Hotspot

獨立的mongod服務器在執行升序寫入時效率最高。這與分片衝突，因為在群集上分散寫入時分片是最有效的。此處描述的技術基本上會創建多個熱點（每個分片上最好創建多個熱點），從而使寫入在整個群集中均勻平衡，但在一個分片內會遞增。

為此，我們使用複合分片鍵。複合鍵中的第一個值是基數較低的粗糙隨機值。您可以將分片鍵的第一部分中的每個值都顯示為一個塊，如圖16-6所示。最終，當您插入更多數據時，它可能會自行解決，儘管它可能永遠不會被整齊地分割（在$ minKey行上）。但是，如果插入足夠​​的數據，則每個隨機值最終應大約有一個塊。隨著您繼續插入數據，您將獲得多個具有相同隨機值的塊，這將我們帶到了分片鍵的第二部分。

分片鍵的第二部分是升序鍵。 這意味著在一個塊中，值始終在增加，如圖16-7中的示例文檔所示。 因此，如果每個分片只有一個塊，那麼您將擁有完美的設置：對每個分片進行遞增寫入，如圖16-8所示。 當然，將n個熱點分佈在n個分片上的n個塊不是很可擴展：添加一個新的分片，由於沒有熱點塊可放置，因此不會寫入任何內容。 因此，您希望每個分片有幾個熱點塊（以便給您增長的空間），但不要太多。 擁有幾個熱點塊將保持遞增寫入的有效性，但是，例如，在一個分片上具有一千個熱點將最終等同於隨機寫入。

您可以將此設置描述為每個塊都是一堆升序的文檔。 每個分片上都有多個堆棧，每個堆棧都遞增直到塊被分割為止。 分割一塊後，新塊中只有一個將成為熱點塊：另一個塊實質上將是“已死”，並且不再增長。 如果堆棧在各個分片上均勻分佈，則寫入將均勻分佈。

# Shard Key Rules and Guidelines

選擇分片密鑰之前，需要注意一些實際限制。

確定要分片的鍵並創建分片鍵應該會使人聯想到索引，因為這兩個概念相似。 實際上，分片鍵通常可能只是您最常使用的索引（或其上的某種變體）。

## 分片鍵限制

分片鍵不能為數組。 如果任何鍵具有數組值，則sh.shardCollection（）將失敗，並且不允許將數組插入該字段。

插入後，文檔的分片鍵值可以修改，除非分片鍵字段是不可變的_id字段。 在4.2之前的舊版MongoDB中，無法修改文檔的分片鍵值。

多數特殊類型的索引不能用於分片鍵。 特別是，您無法分片地理空間索引。 如前所述，允許將哈希索引用於分片鍵。

## Shard Key Cardinality

無論您的分片密鑰是跳躍跳躍還是穩定增長，選擇具有不同值的密鑰都是很重要的。 與索引一樣，分片在高基數字段上表現更好。 例如，如果您的“ logLevel”鍵只有值“ DEBUG”，“ WARN”或“ ERROR”，則MongoDB將無法將數據分成三個以上的塊（因為 分片鍵只有三個不同的值）。 如果您擁有一個幾乎沒有變化的鍵，並且無論如何都希望將其用作分片鍵，則可以通過在該鍵上創建一個複合分片鍵以及變化更大的鍵來實現，例如“ logLevel”和“ timestamp”。 密鑰組合具有高基數很重要。

# Controlling Data Distribution

有時，自動數據分發可能無法滿足您的要求。 本部分為您提供了一些選擇，除了選擇分片鍵並允許MongoDB自動執行所有操作。

隨著您的集群越來越大或越來越忙，這些解決方案變得越來越不實用。 但是，對於小型群集，可能需要更多控制。

## 對多個數據庫和集合使用群集

MongoDB將集合均勻分佈在群集中的每個分片上，如果您要存儲同類數據，則效果很好。 但是，如果您的日誌收集的價值比其他數據“低”，則可能不希望它佔用更昂貴的服務器上的空間。 或者，如果您有一個功能強大的分片，則可能只想將其用於實時收集，而不允許其他收集使用。 您可以創建單獨的集群，但是也可以為MongoDB提供特定的指示，以指示您希望將其放置某些數據的位置。

這表示，“對於該集合的從負無窮到無窮大，請將其存儲在標記為“高”的碎片上。” 這意味著super.important集合中的任何數據都不會存儲在任何其他服務器上。 請注意，這不會影響其他集合的分佈方式：它們仍將在此碎片與其他碎片之間平均分配。 您可以執行類似的操作以將日誌收集保留在低質量的服務器上：

現在，日誌收集將在shard0004和shard0005之間平均分配。

將區域鍵範圍分配給集合不會立即對其產生影響。 這是給平衡器的一條指令，指出運行平衡器時，這些是將集合移至其中的可行目標。 因此，如果整個日誌集合位於shard0002上或在各個shard中平均分配，則所有塊都需要一些時間才能遷移到shard0004和shard0005。

再舉一個例子，也許您不希望在“高”區域的分片上有一個收藏，但是您不在乎它會繼續哪個分片。 您可以對所有非高性能碎片進行分區，以創建新的分組。 碎片可以具有所需的多個區域：

**Tip**
您不能動態分配館藏-即，您不能說“創建館藏時，將其隨機放置到碎片中”。 但是，您可能會完成一項Cron工作，並為您完成了這項工作。

如果您從區域鍵範圍描述的區域中刪除所有分片（例如，如果從“高”區域中刪除shard0000），則平衡器將不會在任何地方分發數據，因為沒有列出任何有效的位置。 所有數據仍然是可讀可寫的； 它只有在您修改標籤或標籤範圍後才能遷移。

要從區域中刪除鍵範圍，請使用sh.removeRangeFromZone（）。 以下是一個示例。 指定的範圍必須與先前為名稱空間some.logs和給定區域定義的範圍完全匹配：

## Manual Sharding

有時，對於復雜的需求或特殊情況，您可能希望完全控制將哪些數據分發到何處。 如果您不想自動分發數據，則可以關閉平衡器，然後使用moveChunk命令手動分發數據。

要關閉平衡器，請使用mongo shell連接到mongos（任何mongos都可以），並使用shell助手sh.stopBalancer（）禁用平衡器：

如果當前正在進行遷移，則此設置在遷移完成之前不會生效。 但是，一旦完成所有機上遷移，平衡器就會停止移動數據。 要驗證禁用後是否沒有正在進行的遷移，請在mongo shell中發出以下命令：

關閉平衡器後，您可以手動移動數據（如有必要）。 首先，通過查看config.chunks找出哪些塊在哪裡：

現在，使用moveChunk命令將塊遷移到其他分片。 指定要遷移的塊的下限，並提供要將塊移動到的分片的名稱：

但是，除非遇到特殊情況，否則應使用MongoDB的自動分片，而不要手動執行。 如果最終遇到了您意料之外的分片熱點，那麼最終可能會將大部分數據放在該分片上。

特別是，請勿將手動設置異常發行版與運行平衡器相結合。 如果平衡器檢測到數量不均的塊，它將簡單地重新整理您的所有工作以使集合再次達到平衡。 如果要使塊分佈不均勻，請使用“為多個數據庫和集合使用集群”中討論的區域分片技術。