本章通過使用MongoDB對x.509的支持來配置身份驗證和傳輸層加密，以確保MongoDB副本集中的客戶端和服務器之間的安全通信的教程，說明如何解決前兩個安全措施。在下一章中，我們將討論在存儲層加密數據。

# MongoDB Authentication and Authorization

雖然身份驗證和授權緊密相連，但必須注意身份驗證與授權不同。身份驗證的目的是驗證用戶的身份，而授權則確定已驗證用戶對資源和操作的訪問權限。

## Authentication Mechanisms

在MongoDB集群上啟用授權可強制執行身份驗證，並確保用戶只能執行其角色所確定的被授權的操作。 MongoDB的社區版本提供對SCRAM（鹽分挑戰響應身份驗證機制）和x.509證書身份驗證的支持。除了SCRAM和x.509，MongoDB Enterprise還支持Kerberos身份驗證和LDAP代理身份驗證。請參閱文檔以獲取有關MongoDB支持的各種身份驗證機制的詳細信息。在本章中，我們將重點介紹x.509身份驗證。 x.509數字證書使用廣泛接受的x.509公鑰基礎結構（PKI）標準來驗證公鑰是否屬於演示者。

## Authorization

在MongoDB中添加用戶時，必須在特定數據庫中創建該用戶。該數據庫是用戶的身份驗證數據庫。您可以為此目的使用任何數據庫。用戶名和身份驗證數據庫用作用戶的唯一標識符。但是，用戶的權限不限於其身份驗證數據庫。創建用戶時，您可以指定用戶可以在他們應該訪問的任何資源上執行的操作。資源包括集群，數據庫和集合。

> read
讀取所有非系統集合以及以下系統集合上的數據：system.indexes，system.js和system.namespaces。

> readWrite
提供與讀取相同的特權，並且能夠修改所有非系統集合和system.js集合上的數據。

>數據庫管理員
執行管理任務，例如與架構相關的任務，建立索引和收集統計信息（不授予用戶和角色管理特權）。

> userAdmin
在當前數據庫上創建和修改角色和用戶。

> dbOwner
組合readWrite，dbAdmin和userAdmin角色授予的特權。

> clusterManager
在群集上執行管理和監視操作。

> clusterMonitor
提供對監視工具（例如MongoDB Cloud Manager和Ops Manager監視代理）的只讀訪問權限。

>hostManager
監視和管理服務器。

clusterAdmin
組合由clusterManager，clusterMonitor和hostManager角色授予的特權，以及dropDatabase操作。

後備：
提供足夠的特權以使用MongoDB Cloud Manager備份代理或Ops Manager備份代理，或使用mongodump備份整個mongod實例。

恢復：
提供從不包含system.profile集合數據的備份還原數據所需的特權。

readAnyDatabase：
提供與所有數據庫（本地和config除外）相同的特權，以及整個集群上的listDatabases操作。

readWriteAnyDatabase：
除了本地和配置外，在所有數據庫上都提供與readWrite相同的特權，並在整個群集上提供listDatabases操作。

userAdminAnyDatabase：
在除本地和配置（實際上是超級用戶角色）之外的所有數據庫上，提供與userAdmin相同的特權。

dbAdminAnyDatabase：
在本地和配置之外的所有數據庫上，提供與dbAdmin相同的特權，並在整個群集上提供listDatabases操作。

根：
提供對readWriteAnyDatabase，dbAdminAnyDatabase，userAdminAnyDatabase，clusterAdmin，還原和備份角色組合的操作和所有資源的訪問。

您還可以創建所謂的“用戶定義角色”，這是自定義角色，將執行特定操作的授權組合在一起，並用名稱標記它們，以便您可以輕鬆地將此組權限授予多個用戶。

對內置角色或用戶定義角色的深入探討不在本章範圍之內。但是，本介紹應該使您對MongoDB授權的可能情況有一個很好的了解。有關更多詳細信息，請參見MongoDB的授權部分。
文檔。

為確保您可以根據需要添加新用戶，必須首先創建一個管理員用戶。啟用身份驗證和授權時，無論使用哪種身份驗證模式，MongoDB都不會創建默認的root用戶或admin用戶（x.509也不例外）。

在MongoDB中，默認情況下不啟用身份驗證和授權。您必須通過使用mongod命令的--auth選項或為MongoDB配置文件中的security.authorization設置指定一個“ enabled”值來顯式啟用它們。

要配置副本集，請先啟用副本集而不啟用身份驗證和授權，然後創建管理員用戶以及每個客戶端所需的用戶。

## Using x.509 Certificates to Authenticate Both Members and Clients

鑑於所有生產MongoDB集群都由多個成員組成，為了保護集群，必須在集群內進行通信的所有服務彼此進行身份驗證。 副本集的每個成員必須與其他成員進行身份驗證才能交換數據。 同樣，客戶端必須通過與其通信的主服務器和任何輔助服務器進行身份驗證。

對於x.509，必須由受信任的證書頒發機構（CA）簽署所有證書。 簽名證明證書的命名主題擁有與該證書關聯的公共密鑰。 CA充當可信任的第三方，以防止中間人攻擊。 

圖19-1描述了用於保護三成員MongoDB副本集的x.509身份驗證。 注意客戶端和副本集成員之間的身份驗證以及與CA的信任關係。

成員和客戶各自具有由CA簽名的自己的證書。 對於生產用途，您的MongoDB部署應使用由單個證書頒發機構生成和簽名的有效證書。您或您的組織可以生成並維護獨立的證書頒發機構，或者可以使用第三方TLS / SSL供應商生成的證書。

我們將用於內部身份驗證以驗證集群中成員身份的證書稱為成員證書。 成員證書和客戶端證書（用於對客戶端進行身份驗證）都具有類似於以下內容的結構：

要與MongoDB中的x.509身份驗證一起使用，成員證書必須具有以下屬性：

* 單個CA必須為群集成員頒發所有x.509證書。

* 在成員證書的主題中找到的專有名稱（DN），必須為以下屬性中的至少一個指定非空值：組織（O），組織單位（OU）或域組件（DC）。

* O，OU和DC屬性必須與其他集群成員的證書中的屬性匹配。

* 公用名（CN）或主題備用名（SAN）必須與群集其他成員使用的服務器的主機名匹配。

# A Tutorial on MongoDB Authentication and Transport Layer Encryption

在本教程中，我們將設置一個根CA和一個中間CA。最佳實踐建議使用中間CA對服務器證書和客戶端證書進行簽名。

## Establish a CA

在為副本集的成員生成簽名證書之前，我們必須首先解決證書頒發機構的問題。如前所述，我們可以生成和維護獨立的證書頒發機構，也可以使用第三方TLS / SSL供應商生成的證書。在本章中，我們將生成自己的CA以用於正在運行的示例。請注意，您可以從為本書維護的GitHub存儲庫中訪問本章中的所有代碼示例。這些示例來自可用於部署安全副本集的腳本。在所有這些示例中，您都會看到此腳本的註釋。

### GENERATE A ROOT CA

為了生成我們的CA，我們將使用OpenSSL。要進行後續操作，請確保您有權訪問本地計算機上的OpenSSL。

根CA位於證書鏈的頂部。這是信任的最終來源。理想情況下，應使用第三方CA。但是，在隔離網絡（通常在大型企業環境中）或出於測試目的的情況下，您需要使用本地CA。

首先，我們將初始化一些變量：

然後，使用openssl req命令，將創建根證書。 由於根是授權鏈的最頂端，因此我們將使用在上一步中創建的私鑰（存儲在root-ca.key中）自簽名此證書。 -x509選項告訴openssl req命令，我們要使用提供給-key選項的私鑰對證書進行自簽名。 輸出是一個名為root-ca.crt的文件：

如果您查看root-ca.crt文件，就會發現它包含根CA的公共證書。 您可以通過查看此命令生成的證書的可讀版本來驗證內容：


### CREATE AN INTERMEDIATE CA FOR SIGNING

現在，我們已經創建了根CA，我們將創建一個用於簽署成員和客戶端證書的中間CA。中間CA僅不過是使用我們的根證書籤名的證書。最佳做法是使用中間CA對服務器（即成員）和客戶端證書進行簽名。通常，CA將使用不同的中間CA來簽署不同類別的證書。如果中間CA受到威脅，並且證書需要撤銷，則僅影響信任樹的一部分，而不是CA簽名的所有證書，就像使用根CA簽名所有證書的情況一樣。

請注意，在上面的語句中，我們使用openssl req命令，然後使用openssl ca命令使用我們的根證書對我們的簽名證書進行簽名。 openssl req命令創建一個簽名請求，openssl ca命令使用該請求作為輸入來創建簽名的中間（簽名）證書。

作為創建簽名CA的最後一步，我們將把根證書（包含我們的根公共密鑰）和簽名證書（包含我們的簽名公共密鑰）連接到單個pem文件中。此文件稍後將作為-tlsCAFile選項的值提供給我們的mongod或客戶端進程。

通過設置根CA和簽名CA，我們現在可以在MongoDB集群中創建用於身份驗證的成員和客戶端證書。

## Generate and Sign Member Certificates

成員證書通常稱為x.509服務器證書。 將這種類型的證書用於mongod和mongos進程。 MongoDB群集的成員使用這些證書來驗證群集中的成員身份。 換句話說，一個mongod使用服務器證書與副本集的其他成員進行身份驗證。

為了為副本集的成員生成證書，我們將使用for循環來生成多個證書。

每個證書涉及三個步驟：

* 使用openssl genrsa命令創建一個新的密鑰對。

* 使用openssl req命令生成密鑰的簽名請求。

* 使用openssl x509命令使用簽名CA簽名並輸出證書。

注意變量$ ou_member。 這表示服務器證書和客戶端證書之間的差異。 服務器和客戶端證書在專有名稱的組織部分中必須不同。 更具體地說，它們必須至少在O，OU或DC值之一上有所不同。

# Generate and Sign Client Certificates

客戶端證書由mongo shell，MongoDB Compass，MongoDB實用程序和工具以及使用MongoDB驅動程序的應用程序使用。 生成客戶端證書的過程基本上與成員證書的過程相同。 一個區別是我們對變量$ ou_client的使用。 這樣可以確保O，OU和DC值的組合與上面生成的服務器證書的組合不同。

## Bring Up the Replica Set Without Authentication and Authorization Enabled

我們可以在不啟用身份驗證的情況下啟動副本集的每個成員，如下所示。 以前，在使用副本集時，我們尚未啟用身份驗證，因此應該看起來很熟悉。 在這裡，我們再次利用了在“生成根CA”（或參閱本章的完整腳本）中定義的一些變量，以及一個循環來啟動副本集的每個成員（mongod）。

請注意，上面的代碼只是構造了一系列命令，將這些命令存儲在JavaScript文件中，然後運行mongo shell執行已創建的小腳本。 這些命令一起在mongo shell中執行時，將連接到在端口27017上運行的mongod（“生成根CA”中設置的$ mongodb_port變量的值），啟動副本集，然後將彼此添加 副本集的兩個mongods（在端口27018和27019上）。

## Create the Admin User

現在，我們將基於在“生成和簽名客戶端證書”中創建的客戶端證書之一創建一個管理員用戶。 從mongo shell或其他客戶端連接以執行管理任務時，我們將以該用戶身份進行身份驗證。 要使用客戶端證書進行身份驗證，必須首先以MongoDB用戶身份添加客戶端證書中主題的值。 每個唯一的x.509客戶端證書都對應一個MongoDB用戶； 也就是說，您不能使用單個客戶端證書來認證一個以上的MongoDB用戶。 我們必須在$ external數據庫中添加用戶； 即認證數據庫是$ external數據庫。

首先，我們將使用openssl x509命令從客戶證書中獲取主題。

## Restart the Replica Set with Authentication and Authorization Enabled

現在我們有了管理員用戶，我們可以重新啟動啟用了身份驗證和授權的副本集，並以客戶端身份連接。如果沒有任何類型的用戶，將無法連接到啟用了auth的副本集。 

讓我們以當前形式停止副本集（不啟用身份驗證）。

現在，我們準備在啟用身份驗證的情況下重新啟動副本集。 在生產環境中，我們會將每個證書和密鑰文件複製到其相應的主機。 在這裡，我們正在localhost上進行所有操作，以簡化操作。 要啟動安全副本集，我們將在每次mongod調用中添加以下命令行選項：

在這裡，我們提供的作為tlsCAFile選項值的文件用於建立信任鏈。 在您回想起時，root-ca.key文件包含根CA的證書以及簽名CA。 通過將此文件提供給mongod進程，我們表明我們希望信任此文件中包含的證書以及這些證書籤名的所有其他證書。

這樣，我們就有了一個三成員副本集，該副本集使用x.509證書進行了安全保護，用於身份驗證和傳輸層加密。 剩下要做的唯一一件事就是連接mongo shell。 我們將使用client1證書進行身份驗證，因為這是我們為其創建管理員用戶的證書。

建立連接後，建議您通過向集合中插入一些數據來進行試驗。 您還應該嘗試使用任何其他用戶（例如，使用client2.pem）進行連接。 嘗試連接將導致類似以下的錯誤。

在本章的教程中，我們介紹了一個使用x.509證書作為身份驗證和加密客戶端與副本集成員之間的通信的基礎的示例。 同樣的過程也適用於分片群集。 關於保護MongoDB集群，請牢記以下幾點：

目錄，根CA和簽名CA，以及為成員計算機或客戶端生成和簽名證書的主機本身，應受到保護，以防止未經授權的訪問。

為簡單起見，本教程中根CA和簽名CA密鑰不受密碼保護。 在生產中，必須使用密碼來保護密鑰免遭未經授權的使用。

我們鼓勵您下載並嘗試在本書的GitHub存儲庫中為本章提供的演示腳本。