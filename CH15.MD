## How MongoDB Tracks Cluster Data

給定其分片鍵，每個mongos必須始終知道在哪裡可以找到文檔。 從理論上講，MongoDB可以跟踪每個文檔的存放位置，但是對於包含數百萬或數十億個文檔的集合而言，這變得很麻煩。 因此，MongoDB將文檔分組為多個塊，這些塊是分片鍵的給定範圍內的文檔。 塊始終位於單個分片上，因此MongoDB可以保留映射到分片的小塊表。

例如，如果用戶集合的分片鍵為{“ age”：1}，則一個塊可能是所有帶有“ age”字段在3到17之間的文檔。如果mongos收到了{“ age”：5}的查詢， 可以將查詢路由到該塊所在的分片。

隨著寫入的進行，塊中文檔的數量和大小可能會發生變化。插入可以使大塊包含更多文檔，而刪除更少文檔。例如，如果我們要為兒童和青春期製作遊戲，我們3-17歲的年齡段可能會越來越大（有人希望）。幾乎我們所有的用戶都將位於該塊中，因此將位於單個碎片上，這在一定程度上違反了分發數據的觀點。因此，一旦塊增長到一定大小，MongoDB就會自動將其拆分為兩個較小的塊。在此示例中，原始數據塊可能被拆分為一個包含3到11歲的文檔的塊，另一個包含12到17歲的文檔。請注意，這兩個塊仍然覆蓋了原始數據塊覆蓋的整個年齡範圍：3-17。隨著這些新塊的增長，可以將它們分成更小的塊，直到每個年齡段都有一個塊為止。

您不能有範圍重疊的塊，例如3-15和12-17。如果可以的話，MongoDB在嘗試查找重疊的年齡時（例如14）將需要檢查兩個塊。僅在一個位置查看就更有效，尤其是當塊開始在集群中移動時。

文檔始終屬於一個且只有一個塊。此規則的一個後果是，您不能將數組字段用作分片鍵，因為MongoDB為數組創建了多個索引條目。例如，如果文檔的“年齡”字段中包含[5、26、83]，則該文檔最多可分為三個塊。

### Chunk Ranges

每個塊均由其包含的範圍來描述。 新分片的集合從一個塊開始，每個文檔都位於該塊中。 該塊的邊界是負無窮到無窮大，在外殼中顯示為$ minKey和$ maxKey。
隨著此塊的增長，MongoDB會自動將其分成兩個塊，範圍從負無窮大到<某些值>，到<某些價值>到無窮大。 兩個塊的<some value>是相同的：較低的塊包含直到（但不包括）<some value>的所有內容，較高的塊包含<some value>的所有內容

### Splitting Chunks

每個分片主要mongod都會跟踪其當前塊，一旦達到某個閾值，就會檢查是否需要對塊進行拆分，如圖15-1和15-2所示。如果確實需要拆分塊，則mongod將從配置服務器請求全局塊大小配置值。然後，它將執行塊拆分並更新配置服務器上的元數據。在配置服務器上創建新的塊文檔，並修改舊塊的範圍（“最大”）。如果該塊是分片的頂部塊，則mongod將請求平衡器將此塊移至其他分片。這樣做的目的是防止在分片密鑰使用單調遞增的密鑰時，分片變得“熱”。

但是，即使對於很大的一塊，碎片也可能找不到任何分割點，因為合法分割一塊的方法數量有限。具有相同分片鍵的任何兩個文檔都必須位於同一塊中，因此，只能在其中分片鍵值發生變化的文檔之間分割這些塊。例如，如果分片鍵為“ age”，則可以在分片鍵更改的位置分割以下塊，如下所示：



如果mongod嘗試進行拆分時其中一台配置服務器已關閉，則mongod將無法更新元數據（如圖15-3所示）。 所有配置服務器都必須啟動並且可以訪問，以進行拆分。 如果mongod繼續接收對該塊的寫入請求，它將繼續嘗試拆分該塊並失敗。 只要配置服務器運行狀況不佳，拆分將繼續不起作用，並且所有拆分嘗試都會減慢mongod和涉及的分片的速度（對於每次傳入的寫入，都會重複圖15-1至15-3所示的過程） ）。 mongod反复嘗試拆分塊而無法執行此過程的過程稱為拆分風暴。 防止分裂風暴的唯一方法是確保您的配置服務器在盡可能多的時間內正常運行。

## The Balancer

平衡器負責遷移數據。 它會定期檢查分片之間的不平衡，如果發現不平衡，將開始遷移塊。 在MongoDB 3.4+版本中，平衡器位於配置服務器副本集的主要成員上； 在此版本之前，每個蒙古人偶爾都扮演“平衡器”的角色。

平衡器是配置服務器副本集主數據庫上的後台進程，該進程監視每個分片上的塊數。 僅當一個分片的數量達到特定的遷移閾值時，該功能才會激活。

假設某些集合已達到閾值，則平衡器將開始遷移塊。它從過載的分片中選擇一個塊，並在遷移之前詢問該分片是否應拆分該塊。一旦進行了必要的拆分，它將把塊遷移到具有更少塊的計算機上。

使用集群的應用程序不需要知道數據正在移動：所有讀取和寫入都會路由到舊塊，直到移動完成。一旦元數據更新，任何嘗試訪問舊位置數據的mongos進程都會收到錯誤消息，這些錯誤對於客戶端不應該看到：mongos將靜默處理錯誤並在新的分片上重試該操作。

這是您可能在mongos日誌中看到的與“無法使用setShardVersion”有關的錯誤的常見原因。當mongos遇到此類錯誤時，它將從配置服務器中查找數據的新位置，更新其塊表，然後再次嘗試該請求。如果它成功地從新位置檢索了數據，它將把它返回給客戶端，就像沒有發生任何錯誤一樣（但是它將在日誌中打印一條消息，指出發生了錯誤）。

如果mongos由於配置服務器不可用而無法檢索新的塊位置，它將向客戶端返回錯誤。這是始終保持配置服務器正常運行非常重要的另一個原因。

## Collations

MongoDB中的排序規則允許為字符串比較指定特定於語言的規則。 這些規則的示例包括如何比較字母和重音符號。 可以對作為默認排序規則的集合進行分片。 有兩個要求：集合必須有一個索引，該索引的前綴是分片鍵，並且索引還必須具有排序規則{locale：“ simple”}。

## Change Streams

更改流允許應用程序跟踪對數據庫中數據的實時更改。在MongoDB 3.6之前的版本中，只有通過拖尾oplog才能實現，並且這是一個易於出錯的複雜操作。變更流為集合，一組集合，數據庫或整個部署中的所有數據更改提供訂閱機制。此功能使用聚合框架。它允許應用程序過濾特定的更改或轉換收到的更改通知。在分片集群中，所有變更流操作必須針對mongos發出。

通過使用全局邏輯時鐘，可以使分片群集中的更改保持有序。這樣可以保證更改順序，並且流通知可以通過其接收順序來安全地解釋。收到更改通知後，mongos需要檢查每個分片，以確保沒有分片看到最近的更改。群集的活動級別和碎片的地理分佈都可能影響此檢查的響應時間。在這些情況下，使用通知過濾器可以縮短響應時間。

**NOTE**
將變更流與分片群集一起使用時，有一些注意事項和警告。 您可以通過發出打開變更流操作來打開變更流。 在分片部署中，必須針對mongos發出此消息。 如果針對具有開放更改流的分片集合運行帶有multi：true的更新操作，則可能會發送孤立文檔的通知。 如果刪除了分片，則可能會導致打開的更改流游標關閉—此外，該游標可能無法完全恢復。

#