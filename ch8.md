# Cardinality
基數表示一個集合對另一個集合有多少個引用。常見的關係是一對一，一對-托尼姆或多對多。例如，假設我們有一個博客應用程序。每個帖子都有一個標題，因此是一對一的關係。每個作者都有很多帖子，所以這是一對多的關係。

帖子有很多標籤，而標籤引用了很多帖子，因此這是多對多關係。使用MongoDB時，將“許多”分為以下幾類在概念上很有用：“許多”和“很少”。例如，您可能在作者和帖子之間是一對一的關係：每個作者只寫幾篇文章。博客文章和標籤之間可能有很多關係：博客文章可能比標籤多得多。但是，博客帖子和評論之間存在一對多的關係：每個帖子都有很多評論。

確定少對多關係可以幫助您決定嵌入什麼和引用什麼。通常，“很少”的關係將更適合嵌入，而“許多”的關係將更適合作為引用。

#Friends, Followers, and Other Inconveniences
與朋友保持親密，將敵人埋藏。
本節介紹社交圖數據的注意事項。 許多社交應用程序需要鏈接人員，內容，關注者，朋友等。 弄清楚如何平衡嵌入和引用此高度連接的信息可能很棘手，但是通常可以將發布，訂閱系統的關注，交往或偏愛簡化為：一個用戶正在訂閱來自另一個用戶的通知。 因此，有兩個需要提高效率的基本操作：存儲訂戶和將事件通知所有相關方。

# DEALING WITH THE WIL WHEATON EFFECT
無論您使用哪種策略，嵌入都只能用於有限數量的子文檔或參考。 如果您有名人用戶，則他們可能會溢出您存儲關注者的任何文檔。對此進行補償的典型方法是使用“架構設計模式”中討論的異常模式，並在必要時使用“延續”文檔。

# 數據處理的優化
要優化您的應用程序，您必須首先通過評估其讀寫性能來確定其瓶頸。 優化讀取通常涉及擁有正確的索引，並在單個文檔中返回盡可能多的信息。 優化寫入操作通常涉及最小化擁有的索引數，並使更新盡可能高效。
在為快速寫入而優化的模式與為快速讀取而優化的模式之間通常要權衡取捨，因此您可能必須決定哪種模式對您的應用程序更重要。 不僅要考慮讀取與寫入的重要性，還應考慮其比例：如果寫入更為重要，但是您要對每個寫入進行一千次讀取，您可能仍要首先優化讀取。

刪除舊數據
一些數據僅在很短的時間內很重要：幾週或幾個月後，這只是在浪費存儲空間。 有三種刪除舊數據的常用選項：使用上限集合，使用TTL集合以及每個時間段刪除集合。
最簡單的選擇是使用一個有上限的集合：將其設置為較大的大小，並讓舊數據最終掉落。 但是，封頂的集合會對您可以執行的操作造成某些限制，並且容易受到流量激增的影響，從而暫時減少了它們可以保留的時間。 有關更多信息，請參見“上限集合”。

第二種選擇是使用TTL集合。 這使您可以更精細地控制何時刪除文檔，但對於寫入量非常大的集合來說可能不夠快：它通過遍歷TTL索引來刪除文檔，就像用戶請求的刪除方法一樣。 但是，如果TTL收集可以跟上，這可能是最容易實現的解決方案。 有關TTL索引的更多信息，請參見“生存時間索引”。 最後一種選擇是使用多個館藏：例如，每月一個館藏。 每月更改時，您的應用程序都會開始使用本月（空）的集合，並在當月和過去幾個月的集合中搜索數據。 一旦集合的存留時間超過六個月，就可以刪除它。 這種策略幾乎可以應付任何流量，但是構建應用程序要復雜得多，因為您必須使用動態集合（或數據庫）名稱，並且可能要查詢多個數據庫。

# Planning Out Databases and Collections
勾勒出文檔的外觀後，您必須決定要放入哪些集合或數據庫。這通常是一個相當直觀的過程，但是需要牢記一些準則。
通常，具有相似架構的文檔應保存在同一集合中。 MongoDB通常不允許組合來自多個集合的數據，因此，如果需要將文檔查詢或匯總在一起，則這些文件是放入一個大集合的理想選擇。例如，您可能有完全不同的“形狀”文檔，但是如果要對其進行匯總，則它們應全部位於同一集合中（或者，如果它們位於單獨的集合中，則可以使用$ merge階段；或者數據庫）。

對於集合，要考慮的主要問題是鎖定（每個文檔都具有讀/寫鎖定）和存儲。通常，如果您有大量的寫工作負載，則可能需要考慮使用多個物理卷來減少I / O瓶頸。使用--directoryperdb選項時，每個數據庫都可以駐留在其自己的目錄中，從而允許您將不同的數據庫裝入不同的捲。因此，您可能希望數據庫中的所有項目具有相似的“質量”，相似的訪問模式或相似的流量級別。

例如，假設您有一個包含多個組件的應用程序：一個日誌記錄組件，它創建大量的價值不高的數據；一個用戶集合；以及幾個用於用戶生成的數據的集合。這些集合具有很高的價值：確保用戶數據的安全非常重要。還有一個用於社交活動的高流量收藏，其重要性較低，但並不像原木那麼重要。該集合主要用於用戶通知，因此它幾乎是僅追加的集合。

按重要性劃分它們，您可能最終得到三個數據庫：日誌，活動和用戶。這種策略的好處是，您可能會發現自己的價值最高的數據也是最少的數據（例如，用戶生成的數據可能不如日誌記錄那麼多）。您可能無法為整個數據集提供SSD，但可能可以為用戶獲得一個SSD，或者您可以為用戶使用RAID10，為日誌和活動使用RAID0。請注意，在使用MongoDB 4.2之前的多個數據庫以及在Aggregation Framework中引入$ merge運算符時，存在一些局限性，它允許您將聚合結果從一個數據庫存儲到另一個數據庫，並在其中存儲另一個集合數據庫。還有一點要注意的是，將現有集合從一個數據庫複製到另一個數據庫時，renameCollection命令的速度較慢，因為它必須將所有文檔複製到新數據庫中。

# Managing Consistency
您必須弄清楚應用程序讀取的一致性。 MongoDB支持多種一致性級別，從始終能夠讀取自己的寫入內容到讀取未知舊數據。如果您要報告活動的最後一年，則可能只需要最近幾天的正確數據。相反，如果您要進行實時交易，則可能需要立即閱讀最新的文章。

要了解如何實現這些不同程度的一致性，了解MongoDB在幕後所做的事情很重要。服務器為每個連接保留請求隊列。客戶端發送請求時，它將被放置在其連接隊列的末尾。連接上的任何後續請求都將在處理先前入隊的操作之後發生。因此，單個連接具有數據庫的一致視圖，並且始終可以讀取其自己的寫入。

請注意，這是每個連接隊列：如果我們打開兩個外殼，將有兩個數據庫連接。如果我們在一個外殼中執行插入操作，則在另一個外殼中的後續查詢可能不會返回插入的文檔。但是，在單個外殼中，如果我們在插入文檔後查詢該文檔，則會返回該文檔。手動複製此行為可能很困難，但是在繁忙的服務器上可能會發生交錯的插入和查詢。當開發人員在一個線程中插入數據，然後檢查數據是否已成功插入另一個線程時，通常會遇到這種情況。一兩分鐘，好像沒有插入數據，然後突然出現。

當使用Ruby，Python和Java驅動程序時，這種行為尤其值得牢記，因為這三個都使用連接池。為了提高效率，這些驅動程序打開了到服務器的多個連接（池），並在服務器之間分配請求。但是，它們都具有保證由單個連接處理一系列請求的機制。 MongoDB驅動程序連接監視和池規範中提供了有關各種語言的連接池的詳細文檔。

當您將讀取發送到輔助副本集（請參見第12章）時，這將成為一個更大的問題。輔助節點可能會落後於主要節點，從而導致在幾秒鐘，幾分鐘甚至幾小時之前讀取數據。有幾種方法可以解決此問題，最簡單的方法是，如果您擔心陳舊性，只需將所有讀取發送到主數據庫即可。
MongoDB提供了readConcern選項，以控制所讀取數據的一致性和隔離性。它可以與writeConcern結合使用，以控制對您的應用程序所作的一致性和可用性保證。有五個級別：“本地”，“可用”，“多數”，“線性化”和“快照”。根據應用程序的不同，在要避免讀取陳舊的情況下，可以考慮使用“多數”，該“多數”僅返回經大多數副本集成員確認並且不會回滾的持久數據。 “ linearizable”也可能是一個選項：它返回的數據反映了在讀取操作開始之前已完成的所有成功的多數確認寫入。 MongoDB可能會等待並發執行的寫入操作完成，然後再返回帶有“ linearizable” readConcern的結果。

Three senior engineers from MongoDB published a paper called
“Tunable Consistency in MongoDB” at the PVLDB conference in
2019. This paper outlines the different MongoDB consistency
models used for replication and how application developers can
utilize the various models.

# Migrating Schemas
