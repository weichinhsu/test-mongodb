# Seeing the Current Operations

查找慢速操作的一種簡單方法是查看運行情況。 任何緩慢的情況都更有可能出現，並且運行時間更長。 不能保證，但是這是邁出良好的第一步，以了解可能會使應用程序變慢的原因。

要查看正在運行的操作，請使用db.currentOp（）函數：

這將顯示數據庫正在執行的操作的列表。這是輸出中一些更重要的字段：

“opid”
操作的唯一標識符。您可以使用此數字來終止操作（請參閱“終止操作”）。

“active”
此操作是否正在運行。如果此字段為false，則表示操作已放棄或正在等待鎖定。

“ secs_running”
此操作的持續時間（以秒為單位）。您可以使用它來查找耗時太長的查詢。

“ microsecs_running”
此操作的持續時間（以微秒為單位）。您可以使用它來查找耗時太長的查詢。

“ op”
操作類型。通常是“查詢”，“插入”，“更新”或“刪除”。請注意，數據庫命令作為查詢處理。

“ desc”
客戶端的標識符。這可以與日誌中的消息相關聯。在我們的示例中，與連接有關的每個日誌消息都將以[conn3]為前綴，因此您可以使用它來對日誌進行grep獲取相關信息。

“鎖”
此操作採用的鎖類型的說明。

“ waitingForLock”
此操作當前是否正在阻止，正在等待獲取鎖。

“ numYields”
該操作產生的次數，釋放其鎖定以允許其他操作進行。 通常，任何搜索文檔的操作（查詢，更新和刪除）都可以產生結果。 僅當有其他操作入隊並等待獲取其鎖時，該操作才會產生。 基本上，如果沒有任何操作處於“ waitingForLock”狀態，那麼當前操作將不會產生。

“ lockstats.timeAcquiringMicros”
此操作花費了多長時間來獲取所需的鎖。 

您可以過濾currentOp以僅查找滿足特定條件的操作，例如，對特定名稱空間的操作或已運行一定時間長度的操作。 您可以通過傳遞查詢參數來過濾結果：

## Finding Problematic Operations

db.currentOp（）的最常見用法是尋找慢速操作。 您可以使用上一節中描述的過濾技術來查找所有花費超過一定時間的查詢，這可能表明索引丟失或字段過濾不正確。

有時，人們會發現正在運行意外查詢，這通常是因為有一個應用服務器在運行舊版或錯誤版本的軟件。 “客戶端”字段可以幫助您跟踪意外操作來自何處。

## Killing Operations

並非所有操作都可以殺死。 通常，只有在操作屈服時才能將其殺死，因此更新，查找和刪除操作都可以被殺死，但是持有或等待鎖的操作通常不能被殺死。

將“ kill”消息發送給操作後，它將在db.currentOp（）輸出中具有“ killed”字段。 但是，直到它從當前操作列表中消失後，它才真正消失。

在MongoDB 4.0中，對killOP方法進行了擴展，使其可以在mongos上運行。 現在，它可以殺死在集群中多個分片上運行的查詢（讀取操作）。 在以前的版本中，這涉及在各個主要mongod上的每個分片上手動發出kill命令。

## False Positives

如果您發現操作緩慢，可能會列出一些長期運行的內部操作。 MongoDB可能有幾個長期運行的請求，具體取決於您的設置。 最常見的是複制線程（它將在盡可能長的時間內繼續從同步源中提取更多操作）和用於分片的寫回偵聽器。 可以忽略local.oplog.rs上所有長時間運行的查詢以及所有writebacklistener命令。

如果您殺死了其中任何一個操作，MongoDB只會重新啟動它們。 但是，通常不應這樣做。 終止複制線程將短暫地停止複制，並且終止回寫偵聽器可能會導致mongos丟失合法的寫入錯誤。

## Preventing Phantom Operations

您可能會遇到MongoDB特定的奇怪問題，尤其是在將數據批量加載到集合中的情況下。假設您有一項工作正在MongoDB上執行數千個更新操作，而MongoDB正在停頓。您可以迅速停止工作並終止當前正在發生的所有更新。但是，即使作業不再運行，您仍然會看到殺死舊的更新就會立即出現新的更新！

如果您使用未確認的寫入來加載數據，則您的應用程序將在MongoDB上觸發寫入，這可能比MongoDB處理它們的速度更快。如果備份了MongoDB，則這些寫操作將堆積在操作系統的套接字緩衝區中。當您取消MongoDB正在處理的寫入時，這使MongoDB可以開始處理緩衝區中的寫入。即使您停止了客戶端發送寫操作，MongoDB也將處理所有寫入緩衝區的寫操作，因為它們已經被“接收”（只是未處理）。

防止這些幻像寫入的最佳方法是執行已確認的寫入：使每個寫入都等到之前的寫入完成為止，而不僅僅是直到之前的寫入位於數據庫服務器上的緩衝區中為止。

# Using the System Profiler

要查找速度較慢的操作，可以使用系統概述，該概述將操作記錄在特殊的system.profile集合中。 探查器可以為您提供大量耗時的信息，但需要付出一定的代價：它會降低mongod的整體性能。 因此，您可能只想定期打開分析器以捕獲流量的一部分。 如果系統已經負擔很重，則可能希望使用本章中介紹的另一種技術來診斷問題。

默認情況下，探查器處於關閉狀態，並且不記錄任何內容。 您可以
通過在外殼程序中運行db.setProfilingLevel（）將其打開：

第2級的意思是“描述所有內容”。 數據庫收到的每個讀取和寫入請求都將記錄在當前數據庫的system.profile集合中。 每個數據庫都啟用了性能分析，這會導致嚴重的性能損失：每次寫入都必須額外寫入一次，並且每次讀取都必須具有寫入鎖定（因為它必須將一個條目寫入system.profile集合）。 但是，它將為您提供有關係統運行情況的詳盡清單：

您可以使用“客戶端”字段來查看哪些用戶正在向數據庫發送哪些操作。 如果您使用的是身份驗證，則還可以查看哪個用戶正在執行每個操作。

通常，您並不關心數據庫正在執行的大多數操作，而只關心較慢的操作。 為此，您可以將分析級別設置為1。默認情況下，級別1概要分析耗時超過100毫秒的操作。 您還可以指定第二個參數，該參數定義“慢”對您的含義。 這將記錄所有耗時超過500毫秒的操作：

通常，將減慢幅度設置為較低值不是一個好主意。 即使進行概要分析，減慢速度也會對mongod產生影響：它設置了在日誌中打印慢速操作的閾值。 因此，如果將減慢設置為2，則即使關閉分析，耗時超過2毫秒的所有操作也會顯示在日誌中。 因此，如果您降低減慢速度來剖析某些東西，則可能需要在關閉性能分析之前再次提高它。

您可以使用db.getProfilingLevel（）查看當前的分析級別。 分析級別不是持久性的：重新啟動數據庫將清除該級別。

有一些用於配置性能分析級別的命令行選項，即--profile級別和--slowms time，但是提高性能分析級別通常是一種臨時調試措施，而不是您希望長期添加到配置中的東西。

在MongoDB 4.2中，通過添加queryHash和planCacheKey字段，擴展了探查器條目和診斷日誌消息以進行讀/寫操作，以幫助改進慢速查詢的標識。 queryHash字符串表示查詢形狀的哈希，並且僅取決於查詢形狀。每個查詢形狀都與一個queryHash關聯，從而使使用相同形狀突出顯示這些查詢變得更加容易。 planCacheKey是與查詢關聯的計劃緩存條目的鍵的哈希。它包括查詢形狀和形狀的當前可用索引的詳細信息。這些幫助您關聯來自探查器的可用信息，以協助進行查詢性能診斷。

如果您打開概要分析並且system.profile集合尚不存在，MongoDB會為其創建一個小型的有限集合（大小為幾兆字節）。如果要長時間運行分析器，則可能沒有足夠的空間來容納需要記錄的操作數量。您可以通過關閉概要分析，刪除system.profile集合併創建一個新的system.profile上限的集合來創建更大的system.profile集合，這正是您想要的大小。然後在數據庫上啟用概要分析。

# Calculating Sizes

為了提供正確數量的磁盤和RAM，了解多少文件，索引，集合和數據庫將佔用多少空間很有用。 有關計算工作集的信息，請參見“計算工作集”。

## Documents

獲取文檔大小的最簡單方法是使用外殼程序的Object.bsonsize（）函數。 傳遞任何文檔以獲取存儲在MongoDB中的大小。 例如，您可以看到將_ids存儲為ObjectIds比將它們存儲為字符串更有效：

實際上，您可以直接從集合中傳遞文檔：

這可以準確地顯示文檔在磁盤上佔用了多少字節。 但是，這不計算填充或索引，填充或索引通常可能是集合大小的重要因素。

## Collections

為了查看整個集合的信息，有一個stats函數：

統計信息從名稱空間（“ sample_mflix.movi​​es”）開始，然後是集合中所有文檔的計數。接下來的幾個字段與集合的大小有關。如果在集合中的每個元素上調用Object.bsonsize（）並加總所有大小，則將得到“大小”：這是集合中文檔在未壓縮時佔用的實際內存字節數。同樣，如果您將“ avgObjSize”乘以“ count”，則會獲得未壓縮的“ size”在內存中。

如前所述，文檔字節總數不包括通過壓縮集合節省的空間。 “ storageSize”可以小於“ size”，以反映壓縮節省的空間。 “ nindexes”是集合上的索引數。

索引直到完成構建才算在“ nindexes”中，並且直到出現在此列表中才可以使用。通常，索引將比它們存儲的數據量大得多。您可以通過使用右平衡索引來最小化此可用空間（如“複合索引簡介”中所述）。隨機分佈的索引通常將具有大約50％的可用空間，而升序索引將具有10％的可用空間。隨著您的集合越來越大，可能難以讀取數十億字節或更多字節的統計數據輸出。因此，您可以輸入比例因子：千字節為1024，千字節為1024 * 1024，依此類推。例如，這將獲得以TB為單位的收集統計信息：

## Databases

首先，我們有數據庫的名稱，數據庫包含的集合數以及數據庫的視圖數。 “對象”是此數據庫中所有集合中文檔的總數。

該文檔的大部分包含有關數據大小的信息。 “ fsTotalSize”應始終是最大的：它是MongoDB實例存儲數據的文件系統上磁盤容量的總大小。 “ fsUsedSize”表示MongoDB當前在該文件系統中使用的總空間。這應該對應於數據目錄中所有文件使用的總空間。

第二大字段通常是“ dataSize”，它是此數據庫中保存的未壓縮數據的大小。這與“ storageSize”不匹配，因為數據通常是在WiredTiger中壓縮的。 “ indexSize”是此數據庫的所有索引佔用的空間量。

db.stats（）可以採用scale參數，就像集合的stats函數一樣。如果在不存在的數據庫上調用db.stats（），則所有值將均為零。

請記住，在具有高鎖定百分比的系統上列出數據庫可能非常慢，並且會阻止其他操作。盡可能避免這樣做。

# Using mongotop and mongostat

MongoDB附帶了一些命令行工具，這些工具可以每隔幾秒鐘打印一次統計信息，從而幫助您確定其功能。 mongotop與頂級Unix實用程序相似：它概述了哪些集合最忙。 您還可以運行mongotop-鎖定，以為您提供每個數據庫的鎖定統計信息。

mongostat提供服務器範圍的信息。 默認情況下，mongostat每秒打印一次統計信息列表，儘管這可以通過在命令行上傳遞不同的秒數來配置。 每個字段都提供自該字段上次打印以來該活動發生了多少次的計數：

插入/查詢/更新/刪除/獲取更多/命令
簡單統計每個操作中有多少操作。

潮紅
mongod將數據刷新到磁盤的次數。

映射的
mongod已映射的內存量。 通常，這大約是數據目錄的大小。

大小
mongod使用的虛擬內存量。 這通常是數據目錄大小的兩倍（一次用於映射文件，一次用於日記）。

資源
mongod正在使用的內存量。 通常，它應盡可能靠近計算機上的所有內存。

鎖定數據庫
花費最多時間的數據庫鎖定在最後一個時間片中。 該字段報告鎖定數據庫的時間百分比以及保持全局鎖定的時間，這意味著該值可能超過100％。

idx小姐％
發生頁錯誤的索引訪問百分比（因為索引條目或正在搜索的索引部分不在內存中，因此mongod必須進入磁盤）。 這是輸出中最混亂的名稱字段。

qr | qw
讀取和寫入的隊列大小（即，有多少讀取和寫入被阻塞，正在等待處理）。

ar | aw
有多少個活動客戶端（即當前正在執行讀寫操作的客戶端）。

netIn
MongoDB計算得出的網絡字節數（不一定與操作系統測量的相同）。

網絡輸出
MongoDB計算出的網絡字節數。 conn此服務器已打開的傳入和傳出連接數。

時間
進行這些統計的時間。

您可以在副本集或分片群集上運行mongostat。 如果使用--discover選項，則mongostat將嘗試從其最初連接的成員中查找集合或集群的所有成員，並將每台服務器每秒打印一行。 對於大型群集，這可能很快變得難以管理，但對於小型群集和可以使用數據並以更易讀的形式顯示數據的工具很有用。

mongostat是一種快速獲取數據庫運行狀況快照的好方法，但是對於長期監視，首選使用MongoDB Atlas或Ops Manager之類的工具（請參閱第22章）。

