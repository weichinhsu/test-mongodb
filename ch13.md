# Starting Members in Standalone Mode

許多維護任務無法在輔助服務器上執行（因為它們涉及寫操作），因此不應在主服務器上執行，因為這可能會對應用程序性能產生影響。 因此，以下各節經常提到以獨立模式啟動服務器。 這意味著重新啟動成員，使其成為獨立服務器，而不是副本集的成員（臨時）。

要以獨立模式啟動成員，請首先查看用於啟動該成員的命令行選項。 假設它們看起來像這樣：

要在此服務器上執行維護，我們可以在沒有replSet選項的情況下重新啟動它。這將使我們能夠像普通的獨立mongod一樣對其進行讀寫。我們不希望該集合中的其他服務器能夠與其聯繫，因此我們將使其在另一個端口上偵聽（這樣其他成員將無法找到它）。最後，我們希望保持dbpath不變，因為我們大概是以某種方式啟動它以操縱服務器數據的。

首先，我們從mongo shell中關閉服務器：

然後，在操作系統外殼程序（例如bash）中，我們在另一個端口上重新啟動mongod，並且沒有replSet參數：

現在它將作為獨立服務器運行，在端口30000上偵聽連接。集合的其他成員將嘗試在端口27017上連接到該集合，並假定它已關閉。

在服務器上完成維護後，我們可以將其關閉並使用其原始選項重新啟動。它將自動與集合的其餘部分同步，複製“離開”時錯過的所有操作。

# Replica Set Configuration

副本集配置始終保存在local.system.replset集合的文檔中。 該文檔在集合的所有成員上都是相同的。 切勿使用更新來更新此文檔。 始終使用rs helper或replSetReconfig命令。

## Creating a Replica Set

通過啟動要成為其成員的mongod，然後通過rs.initiate（）將其中一個配置傳遞給其中一個，來創建副本集：

## Changing Set Members

添加新的set成員時，它的數據目錄中應該沒有任何內容（在這種情況下它將執行初始同步），或者俱有其他成員的數據副本（有關備份和還原的更多信息，請參見第23章）。 副本集成員）。

連接到主要數據庫並添加新成員，如下所示：

另外，您可以指定一個更複雜的成員配置作為文檔：

您還可以通過其“主機”字段刪除成員：

您可以通過重新配置來更改成員的設置。 更改會員設置有一些限制：

* 您不能更改成員的“ _id”。

* 您無法將要發送重新配置的成員的優先級設置為（通常是主要）優先級0。

* 您不能將仲裁者變成非仲裁者，反之亦然。

* 您無法將成員的“ buildIndexes”字段從false更改為true。

值得注意的是，您可以更改成員的“主機”字段。 因此，如果您錯誤地指定了主機（例如，如果您使用公共IP而不是私有IP），則稍後可以返回並簡單地將配置更改為使用正確的IP。

要更改主機名，您可以執行以下操作：

相同的策略也適用於更改任何其他選項：使用rs.config（）獲取配置，修改所需的任何部分，並通過將新配置傳遞給rs.reconfig（）來重新配置該集。

## Creating Larger Sets

副本集總數限制為50個成員，只有7個投票成員。 這是為了減少每個人使每個人心跳所需的網絡流量，並限制選舉花費的時間。

如果創建的副本集具有七個以上的成員，則必須為每個其他成員分配零票。 您可以通過在成員的配置中指定它來做到這一點：

## Forcing Reconfiguration

如果您永久丟失了大部分內容，則可能需要在沒有主要內容的情況下重新配置它。 這有點棘手，因為通常您會將重新配置發送到主數據庫。 在這種情況下，您可以通過向輔助服務器發送reconfig命令來強制重新配置該集。 連接到外殼中的輔助服務器，並使用“ force”選項將其傳遞給重新配置：

強制重配置遵循與普通重配置相同的規則：必鬚髮送帶有正確選項的有效，格式正確的配置。 “強制”選項不允許無效的配置； 它只允許輔助節點接受重新配置。

強制重新配置會大大增加副本集的“版本”數。 您可能會看到它跳躍了成千上萬。 這是正常現象：這是為了防止版本號衝突（以防網絡分區兩側重新配置）。

當輔助服務器接收到重新配置時，它將更新其配置，並將新配置傳遞給其他成員。 如果集合中的其他成員將發送服務器識別為當前配置的成員，則它們只會在配置更改時使用。 因此，如果某些成員更改了主機名，則應從保留其舊主機名的成員強制重新配置。 如果每個成員都有一個新的主機名，則應關閉集合中的每個成員，以獨立模式啟動一個新的主機名，手動更改其local.system.replset文檔，然後重新啟動該成員。

# Manipulating Member State

有幾種方法可以手動更改成員的狀態以進行維護或響應負載。 請注意，除了適當配置集合外，沒有其他方法可以強製成員成為主要成員，在這種情況下，通過為副本集成員賦予比該集合的任何其他成員更高的優先級。

## Turning Primaries into Secondaries

您可以使用stepDown函數將主數據庫降級為輔助數據庫：

這使主要步驟降級到SECONDARY狀態持續60秒。 如果在該時間段內沒有其他主要候選人當選，它將能夠嘗試再次當選。 如果您希望它在更長或更短的時間內保持為次要狀態，則可以指定自己的秒數以使其處於SECONDARY狀態：

## Preventing Elections

如果您需要對主要成員進行一些維護，但又不希望其他任何合格成員成為過渡成員，則可以通過凍結每個成員來強制他們保留次要成員：

同樣，這需要數秒鐘才能使該成員保持為次要成員。

如果您在這段時間之前完成了對主服務器的所有維護，並且想要取消凍結其他成員，只需對每個成員再次運行命令，超時時間為0秒：

如果選擇，未凍結的成員將能夠舉行選舉。 您還可以通過運行rs.freeze（0）來取消凍結已降級的主數據庫。

# Monitoring Replication

能夠監視集合的狀態很重要：不僅所有成員都已啟動，而且它們所處的狀態以及復制的最新狀態。 您可以使用幾個命令來查看副本集信息。 MongoDB託管服務和管理工具（包括Atlas，Cloud Manager和Ops Manager（請參閱第22章））還提供了用於監視關鍵複製指標上的複制和儀表板的機制。

複製的問題通常是暫時的：一台服務器無法訪問另一台服務器，但是現在可以了。 看到這樣的問題的最簡單方法是查看日誌。 確保您知道日誌的存儲位置（以及它們的存儲位置），並且可以訪問它們。

## Getting the Status

您可以運行的最有用的命令之一是replSetGetStatus，它可以獲取有關集合中每個成員的當前信息（從運行它的成員的角度來看）。 Shell中有此命令的幫助程序：

這些是一些最有用的字段：

“self"
該字段僅在運行成員rs.status（）中存在，在本例中為server-2（m1.example.net:27017）。

“ stateStr”
描述服務器狀態的字符串。有關各種狀態的說明，請參見“成員狀態”。

“uptime”
成員可到達的秒數，或自“成員”成員啟動此服務器以來的時間。因此，服務器1已啟動269秒，服務器2和服務器3已啟動14秒。

“ optimeDate”
每個成員的操作日誌中的最後一個操作時間（該成員同步到的時間）。請注意，這是心跳報告的每個成員的狀態，因此此處報告的optime可能會關閉幾秒鐘。

“ lastHeartbeat”
該服務器上次收到“自我”成員的心跳的時間。如果出現網絡問題或服務器繁忙，則可能要超過兩秒鐘之前。

“ pingMs”
該服務器心跳已花費多長時間的運行平均值。這用於確定要從哪個成員進行同步。

“ errmsg”
成員選擇在心跳請求中返回的任何狀態消息。 這些通常只是信息性的，而不是錯誤消息。 例如，服務器3中的“ errmsg”字段指示此服務器正在初始同步中。 十六進制數507e9a30：851是該成員需要完成的操作的時間戳才能完成初始同步。

有幾個字段可以提供重疊的信息。 “狀態”與“ stateStr”相同； 這只是州的內部ID。 “運行狀況”僅反映給定服務器是否可訪問（1）或不可達（0），這也由“ state”和“ stateStr”顯示（如果服務器不可達，它們將為UNKNOWN或DOWN）。 類似地，“ optime”和“ optimeDate”是用兩種方式表示的相同值：一種表示自紀元以來的毫秒數（“ t”：135 ...），另一種表示的是更易於理解的日期。

## Visualizing the Replication Graph

如果在輔助服務器上運行rs.status（），將有一個名為“ syncingTo”的頂級字段。 這將提供此成員要復制的主機。 通過在集合的每個成員上運行replSetGetStatus命令，可以找出複製圖。

例如，假設server1是與server1的連接，server2是與server2的連接，依此類推，您可能會有類似以下內容：

因此，server0是server1的複制源，server1是server2和server3的複制源，而server2是server4的複制源。

MongoDB根據ping時間確定與誰同步。當一個成員跳動另一個成員時，它乘以該請求所花的時間。 MongoDB保持這些時間的運行平均值。當成員必須選擇另一個要同步的成員時，它將在復制中尋找最接近它並在其前面的成員（因此，您不能以一個複制週期結束：成員將僅從主成員或次成員進行複制更進一步）。

這意味著，如果您在輔助數據中心中建立了一個新成員，則與該主數據中心中的成員相比，它更有可能從該數據中心中的另一個成員進行同步（從而使WAN流量最小化），如圖13所示。 1。

但是，自動複製鏈接有一個缺點：更多的複制躍點意味著將寫入複製到所有服務器所花費的時間更長。例如，假設一切都在一個數據中心中，但是由於添加成員時網絡速度的變化，MongoDB最終會在一行中進行複制，如圖13-2所示。

這極不可能，但並非並非不可能。 但是，這可能是不希望的：鏈中的每個次級節點都必須比次級節點“前面”更靠後。 您可以通過使用replSetSyncFrom命令（或rs.syncFrom（）幫助器）修改成員的複制源來解決此問題。

連接到要更改其複制源的輔助節點，然後運行此命令，並將您希望該成員從中同步的服務器傳遞給該輔助節點：

切換同步源可能需要幾秒鐘，但是如果再次在該成員上運行rs.status（），則應該看到“ syncingTo”字段現在顯示“ server0：27017”。

現在，該成員（server4）將繼續從server0複製，直到server0不可用，或者如果它恰好是輔助節點，則大大落後於其他成員。

## Replication Loops

複製循環是指成員最終彼此復制的情況，例如，A正在從B同步，而B正在從C同步，而C正在從A同步。由於復制循環中的所有成員都不可以是主成員，因此成員不會 接收任何要復制的新操作，將會落後。

當成員選擇自動同步對象時，複製循環應該是不可能的。 但是，您可以使用replSetSyncFrom命令強制執行複制循環。 在手動更改同步目標之前，請仔細檢查rs.status（）輸出，並註意不要創建循環。 如果您不選擇從嚴格意義上的成員進行同步，則replSetSyncFromFrom命令將警告您，但是它將允許您進行同步。

## Disabling Chaining

鏈接是指輔助節點與另一個輔助節點（而不是主要節點）同步時。 如前所述，成員可以決定自動與其他成員進行同步。 您可以通過將“ chainingAllowed”設置更改為false（如果未指定，則默認為true）來禁用鏈接，強制所有人從主服務器同步：

將“ chainingAllowed”設置為false時，所有成員都將從主節點同步。 如果主要節點不可用，它們將退回到與次要節點同步的狀態。

## Calculating Lag

跟踪複製的最重要指標之一是輔助服務器與主服務器的同步程度。 滯後是輔助節點落後多遠，這意味著主要節點執行的最後一個操作的時間戳和輔助節點應用的最後一個操作的時間戳之間的差。

您可以使用rs.status（）查看成員的複制狀態，但也可以通過運行rs.printReplicationInfo（）或rs.printSlaveReplicationInfo（）來獲得快速摘要。

rs.printReplicationInfo（）給出了主要操作日誌的摘要，包括其大小和操作日期範圍：

在此示例中，操作日誌大約為10 MB（10 MiB），並且只能容納大約一個小時的操作。 如果這是實際部署，則操作日誌可能應該更大（有關更改操作日誌大小的說明，請參閱下一節）。 我們希望日誌長度至少與進行完全重新同步所需的時間一樣長。 這樣，我們就不會遇到次要對像在完成其初始同步之前從操作日誌的末端掉下來的情況。

**注意**
一旦操作日誌填滿，就通過獲取操作日誌中第一個操作與最後一個操作之間的時間差來計算日誌長度。 如果服務器在oplog中什麼也沒有啟動，則最早的操作將是相對較新的操作。 在這種情況下，即使oplog可能仍具有可用空間，日誌長度也會很小。 對於服務器運行時間足以至少一次寫入整個操作日誌的服務器，長度是更有用的指標。

您還可以使用rs.printSlaveReplicationInfo（）函數來獲取每個成員的syncedTo值以及將最後一個oplog條目寫入每個輔助節點的時間，如以下示例所示：

請記住，副本集成員的延遲是相對於主要對象而不是針對“牆上時間”計算的。 這通常是無關緊要的，但是在寫入量很低的系統上，這可能會導致幻影複製滯後“尖峰”。 例如，假設您每小時寫一次。 寫入之後，在復制之前，輔助站點看起來比主站點要晚一個小時。 但是，它可以在幾毫秒內趕上這一“小時”的操作。 在監視低吞吐量系統時，有時可能會引起混亂。

## Resizing the Oplog

您的主要操作日誌應視為維護窗口。 如果您的主節點的操作日誌長達一個小時，那麼您只有一小時的時間來解決所有出錯的問題，然後再使輔助節點落在後面，必須從頭進行重新同步。 因此，您通常希望擁有一個可以保存幾天到一周的數據的oplog，以便在出現問題時為自己提供喘息的機會。

不幸的是，沒有一種簡單的方法可以告訴您您的Oplog填寫了多長時間。 WiredTiger存儲引擎允許在服務器運行時在線調整操作日誌的大小。 您應該首先在每個輔助副本集成員上執行這些步驟。 一旦對它們進行了更改，則只有在那時，才應該對主數據庫進行更改。 請記住，每台可能成為主服務器的服務器都應該有足夠大的操作日誌，以便為您提供合理的維護窗口。

要增加操作日誌的大小，請執行以下步驟：

1. 連接到副本集成員。 如果啟用了身份驗證，請確保使用具有可以修改本地數據庫的特權的用戶。

2. 驗證操作日誌的當前大小：

3. 更改副本集成員的操作日誌大小：

4. 最後，如果減小了操作日誌的大小，則可能需要運行壓縮文件以回收分配的磁盤空間。 當它是主要成員時，不應針對成員運行它。 請參閱MongoDB文檔中的“更改Oplog的大小”教程，以獲取有關此案例和整個過程的更多詳細信息。

通常，您不應該減小oplog的大小：儘管它可能長達數月之久，但通常有足夠的磁盤空間用於存儲它，並且不會消耗任何寶貴的資源，例如RAM或CPU。

## Building Indexes

如果將索引構建發送到主數據庫，則主數據庫將正常構建索引，然後當輔助數據庫複製“構建索引”操作時，輔助數據庫將構建索引。 儘管這是建立索引的最簡單方法，但是索引構建是資源密集型操作，可能會使成員不可用。 如果所有輔助節點都同時開始建立索引，則幾乎所有集合成員都將脫機，直到索引建立完成。 此過程僅適用於副本集。 對於分片群集，請參閱有關在分片群集上構建索引的MongoDB文檔教程。

因此，您可能希望一次在一個成員上建立索引，以最大程度地減少對應用程序的影響。 為此，請執行以下操作：

1. 關閉輔助服務器。
2. 將其作為獨立服務器重新啟動。
3. 在獨立服務器上構建索引。
4. 索引構建完成後，作為副本集的成員重新啟動服務器。 重新啟動此成員時，如果命令行選項或配置文件中存在disableLogicalSessionCacheRefresh參數，則需要刪除該參數。
5. 對副本集中的每個輔助副本重複步驟1至4。

現在，您應該有一個集合，其中除主要成員之外的每個成員都已建立索引。 現在有兩個選項，您應該選擇對生產系統影響最小的一個：

1. 在主數據庫上建立索引。 如果您的流量較少時有“休息”時間，那可能是構建它的好時機。 您可能還想修改讀取首選項，以在構建進行中暫時將更多負載分流到次要節點上。主數據庫會將索引構建複製到第二數據庫，但是它們已經有了索引，因此對他們來說是空手而歸。

2. 降級主要模塊，然後按照前面概述的步驟2至4進行操作。 這需要故障轉移，但是當舊的主數據庫正在建立其索引時，您將擁有一個正常運行的主數據庫。 其索引構建完成後，可以將其重新引入集合。


請注意，您還可以使用此技術在輔助數據庫上建立與集合其餘部分不同的索引。 這對於脫機處理可能很有用，但請確保具有不同索引的成員永遠不會成為主成員：其優先級應始終為0。

如果要構建唯一索引，請確保主成員不插入重複項或構建主索引。 索引在主要優先級上。否則，主要數據庫可能會插入重複項，從而導致次要數據庫發生復制錯誤。 如果發生這種情況，輔助服務器將自行關閉。 您將不得不將其作為獨立服務器重新啟動，刪除唯一索引，然後重新啟動它。

## Replication on a Budget

客戶端流量（將您的客戶端配置為將所有讀取發送到主客戶端）。 這是為便宜的盒子設置的選項：

“優先級”：0
您不希望該服務器成為主要服務器。

“隱藏”：真實
您不希望客戶端曾經向該輔助服務器發送讀取。

“ buildIndexes”：false
這是可選的，但是它可以大大減輕該服務器必須處理的負載。 如果您需要從該服務器還原，則需要重建索引。

“票數”：0
如果只有兩台計算機，請將此輔助服務器上的“投票”設置為0，以便在該計算機發生故障時，主服務器可以保持為主服務器。 如果您有第三台服務器（甚至只是您的應用程序服務器），請在該服務器上運行仲裁器，而不要將“ votes”設置為0。

這將為您提供安全性和安全性，使您無需再購買兩台高性能服務器即可擁有備用服務器。

